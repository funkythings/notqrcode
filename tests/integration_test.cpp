// This is free and unencumbered software released into the public domain.
//
// Anyone is free to copy, modify, publish, use, compile, sell, or
// distribute this software, either in source code form or as a compiled
// binary, for any purpose, commercial or non-commercial, and by any means.
//
// In jurisdictions that recognize copyright laws, the author or authors
// of this software dedicate any and all copyright interest in the
// software to the public domain. We make this dedication for the benefit
// of the public at large and to the detriment of our heirs and
// successors. We intend this dedication to be an overt act of
// relinquishment in perpetuity of all present and future rights to this
// software under copyright law.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
// EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.
// IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY CLAIM, DAMAGES OR
// OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
// OTHER DEALINGS IN THE SOFTWARE.
//
// For more information, please refer to <http://unlicense.org>
#define CATCH_CONFIG_MAIN
#include <catch2/catch.hpp>
#include <notqrcode/notqrcode_decoder.hpp>
#include <opencv2/opencv.hpp>
#include <fmt/format.h>

using namespace notqrcode;
using notqrcode::util::units::Degrees;

TEST_CASE("Integration Test") {
    // blob detection parameters SPECIFICALLY for files in ../tests/pics
    // Change thresholds
    cv::SimpleBlobDetector::Params blob_params{};
    blob_params.minThreshold = 10;
    blob_params.maxThreshold = 200;

    // Filter by Area.
    blob_params.filterByArea = false;

    // Filter by Circularity
    blob_params.filterByCircularity = false;

    // Filter by Convexity
    blob_params.filterByConvexity = true;
    blob_params.minConvexity = 0.87;

    // Filter by Inertia
    blob_params.filterByInertia = true;
    blob_params.minInertiaRatio = 0.01;

    notqrcode::ImgProcessingParams img_params{};
    img_params.gaussian_size = 5;
    img_params.threshold = 245;
    img_params.threshold_repl_value = 255;
    // these margins are pretty large! Because codes were generated by hand, the precision was pretty bad
    // so high values are required
    img_params.centroid_dist_margin = 8.f;
    img_params.orientation_pt_dist_margin = 8.f;
    img_params.centroid_orientation_ratio = 0.75f;

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_neg90_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("neg_90_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);

        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(-90.0f).epsilon(0.01));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_90_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("90_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(90.0f).epsilon(0.01));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_neg45_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("neg45_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(-45.0f).epsilon(0.01));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_135_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("135_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(135.0f).epsilon(0.01));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_0_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("0_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(0.0f).margin(0.1));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }

    {
        auto img = cv::imread("../tests/pics/rect_bw_16_neg135_xlarge.jpg", cv::IMREAD_GRAYSCALE);
        auto decoder = NotQRCodeDecoder::img_with_params(img, img_params, blob_params);
        decoder.calculate_keypoints(Draw::YES);
        decoder.save_img("neg135_test.jpg");

        auto orientation = decoder.calculate_orientation(Draw::YES);
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Orientation calculation Error: {}", orientation.error));

        REQUIRE(orientation.val == Approx(-135.0f).epsilon(0.01));

        decoder.rotate_keypoints(Degrees(orientation.val));
        auto decoded_point = decoder.decode();
        if (orientation.error != Error::None)
            throw std::runtime_error(fmt::format("Decoder Error: {}", orientation.error));

        REQUIRE(decoded_point.val.x == 165);
        REQUIRE(decoded_point.val.y == 165);
    }
}
